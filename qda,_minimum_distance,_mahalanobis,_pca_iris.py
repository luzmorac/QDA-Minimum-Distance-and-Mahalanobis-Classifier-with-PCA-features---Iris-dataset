# -*- coding: utf-8 -*-
"""QDA, Minimum distance, Mahalanobis, PCA_iris.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hlBjIPOMyMYQ-8O5tusF-3eNMZk9dWN3
"""

pip install numpy pandas scikit-learn seaborn matplotlib scipy

import numpy as np
import pandas as pd
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, accuracy_score
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis as QDA
from scipy.spatial import distance

# Cargar los datos
url = "/content/bezdekIris.data"
columns = ['sepal_length', 'sepal_width', 'petal_length', 'petal_width', 'species']
data = pd.read_csv(url, header=None, names=columns)

# Codificar las especies en valores numéricos
data['species'] = data['species'].map({'Iris-setosa': 0, 'Iris-versicolor': 1, 'Iris-virginica': 2})

# Separar características y etiquetas
X = data.drop('species', axis=1)
y = data['species']

# Estandarizar las características
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Aplicar PCA para reducir a 2 componentes
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

# Dividir los datos en entrenamiento y prueba con una semilla fija
X_train, X_test, y_train, y_test = train_test_split(X_pca, y, test_size=0.3, random_state=42)

# -----------------------------------------------
# Modelo 1: QDA with PCA
# -----------------------------------------------
qda = QDA()
qda.fit(X_train, y_train)
y_pred_qda = qda.predict(X_test)

# Matriz de confusión para QDA
conf_matrix_qda = confusion_matrix(y_test, y_pred_qda)
accuracy_qda = accuracy_score(y_test, y_pred_qda)

# -----------------------------------------------
# Modelo 2: Minimum Distance with PCA
# -----------------------------------------------
def minimum_distance_classifier(X_train, y_train, X_test):
    # Calcular los centroides
    centroids = np.array([X_train[y_train == i].mean(axis=0) for i in np.unique(y_train)])
    # Asignar etiquetas basado en la distancia mínima
    y_pred = [np.argmin([distance.euclidean(x, c) for c in centroids]) for x in X_test]
    return np.array(y_pred)

y_pred_min_dist = minimum_distance_classifier(X_train, y_train, X_test)

# Matriz de confusión para Minimum Distance
conf_matrix_min_dist = confusion_matrix(y_test, y_pred_min_dist)
accuracy_min_dist = accuracy_score(y_test, y_pred_min_dist)

# -----------------------------------------------
# Modelo 3: Mahalanobis Distance with PCA
# -----------------------------------------------
def mahalanobis_distance_classifier(X_train, y_train, X_test):
    # Calcular los centroides
    centroids = np.array([X_train[y_train == i].mean(axis=0) for i in np.unique(y_train)])
    # Calcular la matriz de covarianza inversa
    inv_cov_matrix = np.linalg.inv(np.cov(X_train.T))
    # Asignar etiquetas basado en la distancia de Mahalanobis
    y_pred = [np.argmin([distance.mahalanobis(x, c, inv_cov_matrix) for c in centroids]) for x in X_test]
    return np.array(y_pred)

y_pred_mahalanobis = mahalanobis_distance_classifier(X_train, y_train, X_test)

# Matriz de confusión para Mahalanobis Distance
conf_matrix_mahalanobis = confusion_matrix(y_test, y_pred_mahalanobis)
accuracy_mahalanobis = accuracy_score(y_test, y_pred_mahalanobis)

# -----------------------------------------------
# Comparación de las matrices de confusión en un solo gráfico
# -----------------------------------------------

# Configuración de subplots
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Gráfico de matriz de confusión de QDA
sns.heatmap(conf_matrix_qda, annot=True, cmap='Blues', fmt='g', ax=axes[0])
axes[0].set_title(f'QDA with PCA\nAccuracy: {accuracy_qda:.2f}')
axes[0].set_xlabel('Predicted')
axes[0].set_ylabel('Actual')

# Gráfico de matriz de confusión de Minimum Distance
sns.heatmap(conf_matrix_min_dist, annot=True, cmap='Blues', fmt='g', ax=axes[1])
axes[1].set_title(f'Minimum Distance with PCA\nAccuracy: {accuracy_min_dist:.2f}')
axes[1].set_xlabel('Predicted')
axes[1].set_ylabel('Actual')

# Gráfico de matriz de confusión de Mahalanobis Distance
sns.heatmap(conf_matrix_mahalanobis, annot=True, cmap='Blues', fmt='g', ax=axes[2])
axes[2].set_title(f'Mahalanobis Distance with PCA\nAccuracy: {accuracy_mahalanobis:.2f}')
axes[2].set_xlabel('Predicted')
axes[2].set_ylabel('Actual')

# Mostrar los gráficos
plt.tight_layout()
plt.show()